diff --git a/backend/data/dl_notification_manager.py b/backend/data/dl_notification_manager.py
new file mode 100644
index 0000000..e1a2b34
--- /dev/null
+++ b/backend/data/dl_notification_manager.py
@@
+from __future__ import annotations
+import json
+import sqlite3
+from typing import Any
+
+
+class DLNotificationManager:
+    """Helper class persisting monitor events to *sonic_monitor_log*."""
+
+    def __init__(self, db: sqlite3.Connection) -> None:
+        self._db = db
+
+    # ------------------------------------------------------------------ #
+    # Writes
+    # ------------------------------------------------------------------ #
+    def insert(
+        self,
+        monitor: str,
+        level: str,
+        subject: str,
+        body: str,
+        metadata: dict[str, Any] | None = None,
+    ) -> None:
+        self._db.execute(
+            """INSERT INTO sonic_monitor_log
+                    (monitor_name, level, subject, body, metadata)
+                 VALUES (?, ?, ?, ?, json(?))""",
+            (monitor, level, subject, body, json.dumps(metadata or {})),
+        )
+        self._db.commit()
+
+    # ------------------------------------------------------------------ #
+    # Reads
+    # ------------------------------------------------------------------ #
+    def list(self, status: str = "all", limit: int = 50) -> list[dict]:
+        q = "SELECT * FROM sonic_monitor_log "
+        if status in ("unread", "new"):
+            q += "WHERE read = 0 "
+        q += "ORDER BY created_at DESC LIMIT ?"
+        cur = self._db.execute(q, (limit,))
+        cols = [c[0] for c in cur.description]
+        return [dict(zip(cols, row)) for row in cur.fetchall()]
+
+    def unread_count(self) -> int:
+        return self._db.execute(
+            "SELECT COUNT(*) FROM sonic_monitor_log WHERE read = 0"
+        ).fetchone()[0]
+
+    def mark_all_read(self) -> None:
+        self._db.execute("UPDATE sonic_monitor_log SET read = 1 WHERE read = 0")
+        self._db.commit()
+
+    def mark_read(self, notif_id: str) -> None:
+        self._db.execute(
+            "UPDATE sonic_monitor_log SET read = 1 WHERE id = ?", (notif_id,)
+        )
+        self._db.commit()
+
diff --git a/backend/data/data_locker.py b/backend/data/data_locker.py
index 9c0fabc..2e4bc1d 100644
--- a/backend/data/data_locker.py
+++ b/backend/data/data_locker.py
@@
-import sqlite3
+import sqlite3
+import os
+from pathlib import Path
@@
     def __init__(self, db_path: str):
-        self.db = sqlite3.connect(db_path, check_same_thread=False)
+        self.db = sqlite3.connect(db_path, check_same_thread=False)
         self.db.row_factory = sqlite3.Row
+        self._ensure_notification_table()
+
+    # ------------------------------------------------------------------ #
+    # Notification log bootstrap
+    # ------------------------------------------------------------------ #
+    def _ensure_notification_table(self) -> None:
+        ddl = """CREATE TABLE IF NOT EXISTS sonic_monitor_log (
+                    id           INTEGER PRIMARY KEY AUTOINCREMENT,
+                    monitor_name TEXT    NOT NULL,
+                    level        TEXT    CHECK(level IN ('LOW','MEDIUM','HIGH')),
+                    subject      TEXT    NOT NULL,
+                    body         TEXT    NOT NULL,
+                    metadata     TEXT,
+                    read         INTEGER DEFAULT 0,
+                    created_at   TIMESTAMP DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
+                 );
+                 CREATE INDEX IF NOT EXISTS idx_sonic_log_time
+                     ON sonic_monitor_log(created_at DESC);"""
+        self.db.executescript(ddl)
+
+    # ------------------------------------------------------------------ #
+    # Lazy helpers
+    # ------------------------------------------------------------------ #
+    @property
+    def notifications(self):
+        """Return a singleton `DLNotificationManager`."""
+        from .dl_notification_manager import DLNotificationManager
+
+        if not hasattr(self, "_notif_mgr"):
+            self._notif_mgr = DLNotificationManager(self.db)
+        return self._notif_mgr
@@

diff --git a/backend/core/monitor_core/base_monitor.py b/backend/core/monitor_core/base_monitor.py
index ae3dbe0..0ab1c33 100644
--- a/backend/core/monitor_core/base_monitor.py
+++ b/backend/core/monitor_core/base_monitor.py
@@
-import os, logging, traceback
+import os, logging, traceback

 class BaseMonitor:
+    """Abstract base class for all monitors with unified success/error logging."""
+
+    # ------------------------------------------------------------------ #
+    # Config flags
+    # ------------------------------------------------------------------ #
+    LOG_SUCCESS: bool = bool(int(os.getenv("MONITOR_LOG_SUCCESS", "1")))
+    SUCCESS_LEVEL: str = "LOW"

     def __init__(self, dl):
         self.dl = dl
         self.MONITOR_NAME = self.__class__.__name__

+    # ------------------------------------------------------------------ #
+    # Notification helper
+    # ------------------------------------------------------------------ #
+    def _notify(self, level: str, subject: str, body: str, metadata=None) -> None:
+        try:
+            self.dl.notifications.insert(
+                monitor=self.MONITOR_NAME,
+                level=level,
+                subject=subject,
+                body=body,
+                metadata=metadata,
+            )
+        except Exception:  # never crash because of UI logging
+            logging.exception("Failed to write sonic_monitor_log row")

     def run_cycle(self):
         try:
             result = self._do_work()
-            # existing success handling
+            if self.LOG_SUCCESS:
+                self._notify(
+                    self.SUCCESS_LEVEL,
+                    f"✅ {self.MONITOR_NAME} finished",
+                    f"{self.MONITOR_NAME} completed successfully",
+                    {"result": str(result)[:200]},
+                )
             return result
         except Exception as exc:
-            # existing error handling
+            self._notify(
+                "HIGH",
+                f"❗ {self.MONITOR_NAME} error",
+                str(exc),
+                {"trace": traceback.format_exc()[-1000:]},
+            )
             raise
+
diff --git a/backend/core/notification_service.py b/backend/core/notification_service.py
new file mode 100644
index 0000000..c52df10
--- /dev/null
+++ b/backend/core/notification_service.py
@@
+"""New NotificationService backed by sonic_monitor_log."""
+
+import sqlite3
+from typing import Any, List, Dict
+
+from backend.data.dl_notification_manager import DLNotificationManager
+
+
+class NotificationService:
+    """Drop‑in replacement for legacy service using sonic_monitor_log."""
+
+    def __init__(self, db: sqlite3.Connection) -> None:
+        self._mgr = DLNotificationManager(db)
+
+    # -------- public API -------------------------------------------------- #
+    def list(self, status: str = "all", limit: int = 50) -> List[Dict[str, Any]]:
+        return self._mgr.list(status=status, limit=limit)
+
+    def unread_count(self) -> int:
+        return self._mgr.unread_count()
+
+    def mark_read(self, notif_id: str) -> None:
+        self._mgr.mark_read(notif_id)
+
+    def mark_all_read(self) -> None:
+        self._mgr.mark_all_read()
