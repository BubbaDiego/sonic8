Aave Integration on Polygon: Official APIs, SDKs, and Contracts
Aave V3 and Version Support on Polygon
Aave is a decentralized liquidity protocol available on Ethereum and other major networks (including Polygon)aave.com. The latest Aave V3 release is the primary version to use on Polygon, offering improved efficiency and new features (e.g. high-efficiency mode, supply/borrow caps). Aave V3 provides secure, composable access to lending markets via battle-tested smart contracts and robust SDKsaave.com. (Aave V2 is still operational on some networks, with similar core functionality; see Legacy Support below.)
Developers integrating Aave on Polygon should target Aave V3. It enables supplying assets and borrowing against collateral with over-collateralization enforced for safetyaave.comaave.com. The protocol manages risk with concepts like Health Factor and liquidation thresholds to protect against under-collateralizationaave.comaave.com. All key operations are mediated by Aave’s smart contracts deployed on Polygon’s network, which have official addresses and ABIs published for integrators (e.g. via the Aave Address Book repository)aave.com. These contracts and tools are version-specific – for instance, the V3 “Pool” contract replaces the V2 “LendingPool” – so it’s important to use the correct interfaces for V3.
Official Aave SDKs and APIs for Integration
Aave offers canonical integration libraries and APIs to simplify building applications (including console apps) without needing to write low-level contract calls from scratch. According to Aave’s documentation, developers can leverage the official React SDK, TypeScript SDK, or GraphQL API to integrate core protocol operations and data directly into their productsaave.com. All these tools are maintained by Aave and support Polygon along with other networks by specifying the desired chain/network ID.
Aave TypeScript SDK (@aave/client)
For a console-based Node.js application, the Aave TypeScript SDK is an ideal choice. It provides a type-safe, low-level client for Aave V3, acting as a lightweight abstraction over Aave’s GraphQL APIaave.com. The SDK is designed for backend or server-side usage (no browser required), making it well-suited for a CLI tool. Developers can install the SDK via NPM (npm install @aave/client@latest)aave.com and instantiate an AaveClient to start interacting with the protocol:
import { AaveClient } from "@aave/client";
export const client = AaveClient.create();

aave.com
Once initialized, the SDK exposes “actions” corresponding to Aave operations (supply, borrow, repay, etc.), available from @aave/client/actions. Each action returns a result object rather than throwing, following a functional error-handling pattern. For example, calling an action like supply(...) yields a ResultAsync that can be awaited and checked with result.isOk() or result.isErr()aave.comaave.com. This approach encourages explicit error handling in a type-safe way.
Transaction Workflow: Actions in the SDK do not themselves send transactions; they produce transaction data or “execution plans.” To actually submit a transaction to Polygon, the SDK provides helpers like sendWith for various wallet libraries (e.g. viem or ethers)aave.comaave.com. In practice, you would:


Prepare the action result (which could be a single tx or a multi-step plan if approvals are needed). For example, const plan = supply(client, {...params...}).


Send the transaction(s) by chaining the plan with sendWith(wallet) and then waiting for confirmation. The SDK differentiates simple one-step actions vs. complex actions that need prior ERC-20 approvalaave.com. If an approval is required, the execution plan will indicate it (as an ApprovalRequired step), and you send two transactions in sequence – first the approval, then the supply/borrowaave.comaave.com. If no approval is needed (e.g. using a permit signature or already approved), the plan is a single TransactionRequest that can be sent directlyaave.com.


Handle the result using the Result object. On success you get a transaction hash; on failure, standardized error types (e.g. SigningError, TransactionError) are provided for debuggingaave.comaave.com.


In summary, the TS SDK lets you build a console app that calls Aave with high-level commands while it manages the low-level GraphQL queries and transaction formatting under the hood. It supports integration with popular Ethereum wallet libraries for signing, including Viem, Ethers (v6), and othersaave.comaave.com. This means your CLI can use a private key or signer to execute the Aave operations on Polygon through the SDK.
Aave GraphQL API
For integrators who prefer to query data or construct transactions directly, Aave provides a GraphQL API at the endpoint https://api.v3.aave.com/graphql aave.com. This is a low-level, network-agnostic API that covers both read operations (fetching market info, user positions, etc.) and transaction generation queries. It is the underlying service that the TS SDK calls, and can be used independently in any environment with HTTP capabilities (even curl)aave.com. The GraphQL API is comprehensive, allowing you to retrieve all on-chain data needed for a custom dashboard or tool, and to prepare transactions that you can then sign and broadcast.
Key aspects of the GraphQL interface:


Market and Position Queries: You can query current reserve data (liquidity, interest rates, APYs, etc.) and a user’s positions (supplied and borrowed amounts, collateral usage, health factor) easily. For example, a GraphQL query can fetch all reserves in the Polygon market along with their parameters, or fetch all of a given user’s supply and borrow balancesaave.com. This eliminates the need to manually read multiple contract storage values. (See Data Retrieval below for specific data available.)


Transaction Preparation: The GraphQL API defines “transaction” queries that return either a TransactionRequest (for simple one-tx operations) or an ExecutionPlan union (for operations needing an approval step)aave.comaave.com. For instance, a query like mutation { supply(args…) } will not execute the supply on-chain immediately, but return the structured data (target contract address, encoded call data, etc.) needed to perform the supply. If the token wasn’t approved yet, the response might include an ApprovalRequired object containing the approval transaction and the original transaction. Your application can use this information to prompt the user or automatically send both transactions in order.


Because this API is accessed over HTTPS, it is well-suited for backends or even directly from a Node.js CLI script. It’s “canonical” in that it reflects exactly what the Aave front-end and SDK use. The GraphQL schema covers all V3 markets (Ethereum, Polygon, Avalanche, etc.), identified by chain IDs in queries. (Example: you can query chains { name, chainId } to see all supported networksaave.comaave.com.) Using the GraphQL API ensures you rely on up-to-date protocol data and transaction building logic maintained by Aave.
Note: After sending a transaction on-chain, the GraphQL API may take a short time to reflect the state change due to caching. It provides a query hadProcessedKnownTransaction(txHash, operationType) that your app can call to confirm the Aave backend has indexed your transactionaave.com – useful to know when your local view of positions can be refreshed.
Other Official Tools


Aave React SDK: For completeness, Aave also offers a React Hooks based SDK (@aave/react) intended for web front-endsaave.com. It provides convenient hooks like useSupply, useBorrow, etc., that internally use the same GraphQL/TS client logic. In a console application (non-web), you wouldn’t use the React SDK, but it’s good to know it exists as it confirms the underlying APIs are consistent. For example, the React hook useUserSupplies can fetch a user’s supply positions across marketsaave.comaave.com, and useSupply prepares supply execution plans similarly to the TS SDK approachaave.comaave.com.


Address Book and Deployed Addresses: Aave publishes all contract addresses and ABIs for each network. On Polygon, the Aave V3 “Pool” contract address, plus auxiliary contracts (data providers, etc.), are available via the official Aave Address Book (an NPM package and GitHub repo)aave.com. This allows your application to programmatically obtain addresses instead of hard-coding them. Additionally, Aave’s on-chain PoolAddressesProvider registry can be queried to get the current Pool, or other key contract addresses for the Polygon marketaave.com. (Using the address provider is more of a solidity-level approach; most JavaScript apps will use the published address constants or the GraphQL service which inherently knows the addresses.)


Core Aave Smart Contracts (V3)
When building directly on the smart contract level, the primary interface is the Aave Pool contract. In Aave V3, almost all user actions funnel through this Pool contract. It is an upgradeable proxy that is the main user-facing contract for the liquidity protocolaave.com. The Polygon deployment of Aave V3 has its own Pool instance (distinct from Ethereum’s, etc.), but functionally they behave the same.
Key V3 Contracts on Polygon:


Pool: Provides the core methods to supply and withdraw assets, borrow and repay loans, manage collateral, flash-loan, and liquidate positionsaave.com. In code, these correspond to functions like supply(), withdraw(), borrow(), repay(), setUserUseReserveAsCollateral() (to toggle collateral usage), and so onaave.comaave.com. All these methods are documented in the Aave V3 contract specs. For Polygon integration, you will need the Pool’s address (e.g. via Address Book) and ABI. Calls to Pool typically require proper ERC-20 approvals (or permit signatures) beforehand for asset transfers.


aTokens and Debt Tokens: When you supply assets, the Pool mints aTokens (ERC-20 tokens prefixed with “a”, e.g. aUSDC) to your address representing your depositaave.com. These aTokens automatically accrue interest (their balance increases over time) reflecting the yield from borrowers. Conversely, when borrowing, Aave V3 uses variable debt tokens (like variableDebtUSDC) to represent the debtaave.com. These are also ERC-20 (non-transferrable) tokens that increase in balance as interest accrues, tracking what the user owes. Your console app might not interact with these tokens directly, but understanding them is important – e.g. a user’s deposit balance is the aToken balance, and repaying a loan effectively burns their debt tokens.


Oracle and Data Contracts: To fetch on-chain data, Aave V3 provides read-only helper contracts. Notably, UiPoolDataProvider and AaveProtocolDataProvider can be called to get comprehensive data about reserves and user positions in one callaave.comaave.com. For example, UiPoolDataProvider.getUserReservesData(address provider, address user) returns an array of all the user’s deposit/borrow info across a marketaave.comaave.com. These view contracts are used by Aave’s own interface to efficiently load dashboard informationaave.com. In a CLI app, you could call them via a web3/ethers provider if you need on-chain data without relying on the GraphQL API. (Alternatively, as mentioned, the GraphQL API already aggregates this data for you.)


Other peripheral contracts: There are additional modules like Incentives Controller (for reward emissions), WrappedTokenGateway (to handle supplying native MATIC by wrapping to WMATIC behind the scenes), and PoolConfigurator (for governance to set risk parameters). For basic functionality (supply/borrow on Polygon), you typically won’t interact with these directly. One exception is the Wrapped Token Gateway: if your app wants to let users deposit Polygon’s native MATIC directly, you’d call the depositETH() function on the WETH/MATIC gateway contract which wraps MATIC to WMATIC and supplies it in one stepaave.comaave.com. The Aave SDK/GraphQL can abstract this by allowing Reserve.acceptsNative to be used for the same effectaave.com.


Usage Patterns for Basic Aave Operations (V3)
Using the above tools and contracts, your console application can implement all basic Aave actions on Polygon. Typically, the app will present a menu (numbered options) for the user to choose actions like Supply Asset, Borrow Asset, View Positions, etc., then execute the corresponding sequence. Below we summarize how each core operation is performed using Aave’s canonical interfaces:
Supplying Assets (Deposits)
Supply (Deposit): To supply an asset to Aave, the user must grant permission for the Aave Pool to transfer the asset from their wallet. This is done either by sending an ERC-20 approve() transaction in advance or by using an EIP-2612 permit signature to allow the transfer in a gasless manner. Aave V3 supports permits on many assets, enabling one-step supply with no separate approval transactionaave.comaave.com (the SDK and UI will use this if permitSupported=true for the assetaave.comaave.com).
After ensuring approval, the app calls the Pool.supply(asset, amount, onBehalfOf, referralCode) function on Polygon’s Pool contractaave.com. In practice, onBehalfOf is usually the user’s own address (unless supplying to someone else’s account), and referralCode is just 0 (Aave’s referral program is currently inactive)aave.com. For example, supplying 100 USDC will result in the Pool transferring 100 USDC from the user and minting 100 aUSDC to the user’s addressaave.comaave.com. These aUSDC tokens represent the user’s deposit accruing interest. The TS SDK provides a high-level supply action which automates these steps: it will check if an approval is needed and either return an ApprovalRequired plan or a ready TransactionRequest for the supplyaave.comaave.com. The GraphQL API likewise has a supply mutation that returns the structured transaction data.
Withdraw (Redeem): To withdraw, the user calls Pool.withdraw(asset, amount, receiver) to redeem their aTokens for the underlying asset. A withdraw will burn the specified amount of aTokens and transfer the corresponding underlying asset back to the user. If the user specifies amount = type(uint256).max, Aave will redeem the full balance of that assetaave.comaave.com. In the console app, this could be an option like “Withdraw X units of asset Y”, which triggers the withdraw call. No separate approval is needed for withdraws (since aTokens are burned internally). The only constraint is liquidity – you cannot withdraw more than what’s available in the pool’s reserves at the moment, otherwise the transaction will revert due to insufficient liquidity. The SDK action withdraw and GraphQL withdraw query will handle creating the transaction. Upon successful withdrawal, the user’s aToken balance decreases and they receive the asset back (plus any interest earned while it was deposited).
Borrowing Assets
Borrow: Borrowing allows a user to take out a loan of an asset against their deposited collateral. The user must have collateral enabled and sufficient in value to cover the borrow (respecting the LTV ratios of those collateral assets). The app should first ensure the user has some collateral supplied and that it’s flagged as usable for borrowing (by default, assets are enabled as collateral when supplied, unless toggled off). When the user chooses to borrow, the app will call Pool.borrow(asset, amount, interestRateMode, referralCode, onBehalfOf)aave.com. In Aave V3, there is only one interest rate mode (variable), so interestRateMode is always 2 for a variable-rate loanaave.com. (Stable rate borrowing is not supported on Aave V3 Polygon). The onBehalfOf is typically the borrower’s own address (unless using credit delegation, an advanced case). If the borrow is valid (the user’s health factor remains above 1 after borrowing), the Pool will mint the corresponding variableDebtToken to the user (tracking the debt) and transfer the borrowed asset to the user’s walletaave.comaave.com.
From an integration perspective, borrowing often requires no prior approval (since taking a loan doesn’t involve transferring an asset from the user’s wallet; rather it sends new assets to the user). However, if the user is borrowing on behalf of someone else via credit delegation, the delegator must have given an allowance on the debt token. That is an edge case – the common case is borrowing for oneself, which the Pool handles directly. The TS SDK’s borrow action and GraphQL borrow query will produce a single TransactionRequest if the borrow is allowed, or an error if it would violate risk parameters (e.g., insufficient collateral or asset is not borrowable).
Repay: To repay a loan, the user needs to return the borrowed asset (plus any accrued interest) to Aave. Similar to supplying, the Pool contract needs an allowance to pull the repayment amount from the user. The app should either prompt an ERC20 approval for the debt asset or use a permit if supported, or use the alternative repay method that uses aTokens. There are two ways to repay:


Calling Pool.repay(asset, amount, interestRateMode, onBehalfOf), after approving the token. This will burn the user’s debt tokens by up to amount (if amount is larger than the actual owed, it simply repays all debt)aave.comaave.com. The Pool will transfer amount of the asset from the user’s wallet to clear the debt. The Aave docs note that you can use amount = type(uint256).max to indicate “repay all” without knowing the exact remaining debtaave.com. The onBehalfOf parameter allows paying back someone else’s loan if you have their permission (or are a credit delegator); usually this is just the user’s own address.


A variant Pool.repayWithATokens(asset, amount, interestRateMode) which lets a user repay by burning their aTokens of the same asset instead of using wallet balanceaave.comaave.com. In practice, this means if a user has also supplied the asset they borrowed, Aave can net the debt against their collateral (this is useful for self-repay or automated strategies). For example, if a user has 50 aUSDC and owes 20 USDC, repayWithATokens(USDC, 20, 2) will destroy 20 of the user’s aUSDC and erase the debt – effectively withdrawing and repaying in one step.


Additionally, Aave V3 provides repayWithPermit, combining the approval and repay in one transaction by using a signed permit (similar to supply with permit)aave.comaave.com. This is convenient for UIs; in a CLI, it might be less common unless the user can easily sign a permit offline.


For a console app, the normal flow is: user selects “Repay”, specify asset and amount, the app checks permit support and either calls the permit signing flow or instructs the user to approve, then calls repay on the Pool. The TS SDK repay action will handle the allowance logic (and can automatically use permit if available), returning an ExecutionPlan if an approval step is neededaave.comaave.com. Once the transaction is sent, if successful, the user’s variable debt for that asset is reduced or cleared. The app should then update the user’s borrow balance and health factor accordingly.
Managing Collateral and Checking Positions
Enabling/Disabling Collateral: A user can choose which of their supplied assets are being used as collateral for borrowing. By default, most assets (except those with 0% LTV or in isolation mode) are enabled as collateral when supplied. To change this, the Pool.setUserUseReserveAsCollateral(asset, useAsCollateral) function is usedaave.com. Setting useAsCollateral=false will prevent that asset from contributing to borrowing power (useful if the user wants to avoid risking a particular asset in liquidation). However, Aave won’t allow disabling collateral that is currently needed for an open loan (doing so could drop Health Factor below 1)aave.comaave.com. In a UI, this corresponds to a toggle. In a console app, you might list the user’s supplied assets and allow them to toggle collateral on/off by calling this function. This is a simple transaction (no approvals needed), and the SDK offers it as an action as well.
Fetching User Positions and Health Factor: To present the user’s current positions (their supplied amounts, borrowed amounts, available borrow headroom, and health factor), you will use Aave’s data querying interfaces rather than direct contract calls for each value. The GraphQL API or TS SDK can fetch aggregated position data easily. For example, the docs highlight that you can query a user’s supply and borrow balances across all reserves, along with their Health Factor and collateral usage, in one goaave.com. The React/TS SDK provides convenience hooks and functions like getUserAccountData or useUserMarketState which return the user’s overall position stats including total collateral value, total debt, LTV, and Health Factoraave.comaave.com. Under the hood, these likely call the UiPoolDataProvider.getUserReservesData and related methods.
In a console app, you can either call the GraphQL userPositions queries or use the AaveProtocolDataProvider contract. The DataProvider’s getUserReservesData(providerAddress, userAddress) will return an array of structs with each reserve the user has interacted with (with fields like scaled aToken balance, scaled debt, and whether collateral is enabled)aave.comaave.com. It also provides getUserAccountData(user) which directly gives aggregate numbers (total collateral in ETH, total debt, available borrow, liquidation threshold, and Health Factor) – this is how Aave’s front-end gets the Health Factor in one call. Using these, your application can display the user’s current supply balances, borrow balances, and health factor in the menu. The Aave docs emphasize that a variety of user and market data is accessible: “market data: total liquidity, rates, risk params… and user position data: supplied balances, borrow balances, collateral status, Health Factor, etc.”aave.com. All of that is available through the official APIs.
Example: Suppose a user chooses “View My Dashboard” in your CLI. Your app might then call the GraphQL API with a query for the Polygon market including the user’s positions. The result can be parsed to show each supplied asset (with amount and current interest APY), each borrowed asset (with amount and interest rate), the user’s current Health Factor (if any loans open), and their borrowing capacity remaining. This uses canonical data – either via GraphQL or via calling UiPoolDataProvider.getUserReservesData and formatting the results using the Aave Utilities SDK (which has helpers to format these raw numbers)aave.comaave.com. By relying on these official data sources, you ensure your app’s information is accurate and up-to-date with Aave’s latest parameters.
Emphasizing Canonical Tools and Best Practices
Across all the above operations, the guiding principle is to use Aave’s official, documented interfaces rather than inventing custom workflows. This ensures compatibility with Aave’s security model and upgradability:


Use the Aave V3 Pool contract for all operations (on Polygon, that is the V3 Pool for the Polygon market) – it is the single entry point that Aave expects users to interact withaave.com. Avoid calling lower-level contracts (like aTokens or debt tokens methods) except to read balances; the Pool contract orchestrates all state changes safely.


Use the Aave SDKs or GraphQL for convenience and reliability. They encapsulate the correct sequence of calls (including handling of approvals and permit signatures) as per Aave’s documentation. For example, sending a supply without approval will fail; the SDK prevents that by either using a permit or prompting an approval firstaave.comaave.com. By following these patterns, your console app will behave just like the official Aave app logic.


Permits and Gas Optimization: The official docs highlight EIP-2612 permit usage to streamline transactionsaave.com. Implementing this (the SDK can do it automatically if you provide the user’s signature) means your app stays in line with Aave’s recommended gas-optimizations (single-step supply or repay). It’s not mandatory, but it is a canonical feature of Aave-supported assets.


Network Configuration: Ensure you target the correct chain ID for Polygon (e.g. chainId 137 for Polygon mainnet) when using the SDK or GraphQL. The Aave tools typically allow specifying an array of chain IDs or a specific market’s address. For instance, when initializing the SDK or calling certain methods, you might pass chainId(137) for Polygonaave.com. The AaveClient by default might include all networks or you can filter to Polygon’s market if needed.


Handling Responses: Both the SDK and GraphQL return structured data. Stick to their formats – e.g., check result.isOk() as shown in docsaave.comaave.com, or if using GraphQL, handle the possibility of an InsufficientBalanceError in an ExecutionPlan (which indicates the user’s wallet doesn’t have enough of the asset to do something)aave.comaave.com. These are documented in Aave’s resources and using them will cover edge cases cleanly.


Legacy Versions (Aave V2) and Support
While Aave V3 is the recommended version on Polygon, Aave V2 is still active on some networks (Polygon had a V2 market prior to V3 launch). If your application needed to support Aave V2 as well, note that the integration methods are similar but use older interfaces. In V2, the main contract was called the LendingPool, and it exposed functions like deposit(), withdraw(), borrow(), repay() analogous to the V3 Pool’s methodsaave.com. The addresses and ABIs differ (and V2 lacks features like supply caps or eMode), but conceptually supply/borrow are the same process (with ERC-20 approvals, aTokens, etc.). Aave V2 provided official resources like subgraph endpoints for dataaave.com and an older JavaScript SDK on GitHubaave.com. Those are now largely superseded by the V3 GraphQL and new SDK. If building new, focus on V3. Only fall back to V2 contracts if you specifically need to interact with an asset that hasn’t migrated to V3 yet. The Aave docs “Legacy Versions” section and the Aave Address Book can provide the necessary info for V2 if needed, but do not mix V2 and V3 calls for the same market – they are separate deployments.
In summary, to build a console-driven application for Aave on Polygon, use the official Aave V3 SDK or GraphQL API for all interactions, and invoke the Aave V3 Pool contract for executing supplies, borrows, repayments, etc. This ensures you are aligned with Aave’s supported integration pathways. By following the documented patterns – obtaining user approval or permit, using the Pool’s methods, and retrieving data from Aave’s provided endpoints – your CLI app will reliably support basic Aave functionality on Polygon without deviating from canonical, proven methods.aave.comaave.com
Sources:


Aave V3 Developer Documentation (Polygon integration, SDKs, and contracts)aave.comaave.comaave.comaave.com


Aave Protocol Smart Contracts Referenceaave.comaave.comaave.comaave.com


Aave GraphQL API and TypeScript SDK Guidesaave.comaave.comaave.com


Aave V3 Data Providers and User Position Query Documentationaave.comaave.comaave.com


Aave Legacy (V2) Documentation for comparisonaave.comaave.com

Sources